using GraphemeSplitter;
using System;
using System.IO;
using System.Linq;

namespace GraphemeBreakPropertyCodeGenerator
{
    /// <summary>
    /// generates `switch` codes from GraphemeBreakProperty definition in unicode.org
    ///
    /// http://www.unicode.org/Public/9.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
    /// http://www.unicode.org/Public/10.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {
            //Generate(UnicodeVersion.V9);
            Generate(UnicodeVersion.V10);
        }

        static void Generate(UnicodeVersion version)
        {
            var items = Loader.LoadProperties(version);

            var pathFormat = "../GraphemeBreakPropertyCodeGeneratorTest/Benchmark.{0}.cs";
            var ns = "GraphemeSplitter";
            var tn = "Benchmark";

            using (var w = new StreamWriter(string.Format(pathFormat, "switch")))
                GenerateSwitchCode(items, ns, tn, "GetBySwitch", w);

            using (var w = new StreamWriter(string.Format(pathFormat, "if")))
                GenerateIfCode(items, ns, tn, "GetByIf", w);

            using (var w = new StreamWriter(string.Format(pathFormat, "items")))
                GenerateItemsCode(items, ns, tn, w);
        }

        static void GenerateHeader(string @namespace, string typeName, string methodName, StreamWriter w)
        {
            w.WriteLine($@"//generated by GraphemeBreakPropertyCodeGenerator

using static {@namespace}.GraphemeBreakProperty;

namespace {@namespace}
{{
    partial class {typeName}
    {{");

            if (methodName != null)
                w.WriteLine($@"        static GraphemeBreakProperty {methodName}(int value)
        {{");
        }

        static void GenerateSwitchCode(PropertyItem[] items, string @namespace, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(@namespace, typeName, methodName, w);

            w.WriteLine(@"            switch (value)
            {");

            var groups = items.GroupBy(x => x.Property);

            foreach (var g in groups)
            {
                foreach (var item in g)
                {
                    for (int i = item.Min; i <= item.Max; i++)
                    {
                        w.WriteLine($"                case {i}:");
                    }
                }
                w.WriteLine($"                    return {g.Key};");
            }

            w.WriteLine(@"                default: return Invalid;
            }
        }
    }
}");
        }


        static void GenerateIfCode(PropertyItem[] items, string @namespace, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(@namespace, typeName, methodName, w);

            foreach (var item in items)
            {
                if (item.Min == item.Max)
                    w.WriteLine($"            if (value == {item.Max}) return {item.Property};");
                else
                    w.WriteLine($"            if ({item.Min} <= value && value <= {item.Max}) return {item.Property};");
            }

            w.WriteLine(@"            return Invalid;
        }
    }
}");
        }

        static void GenerateItemsCode(PropertyItem[] items, string @namespace, string typeName, StreamWriter w)
        {
            GenerateHeader(@namespace, typeName, null, w);

            w.WriteLine(@"        static readonly PropertyItem[] Items = new[]
        {
");

            foreach (var item in items.OrderBy(x => x.Min))
            {
                w.WriteLine($"            new PropertyItem({item.Min}, {item.Max}, {item.Property}),");
            }

            w.WriteLine(@"        };
    }
}");
        }
    }
}
