using GraphemeSplitter;
using System;
using System.IO;
using System.Linq;

namespace GraphemeBreakPropertyCodeGenerator
{
    /// <summary>
    /// generates `switch` codes from GraphemeBreakProperty definition in unicode.org
    ///
    /// http://www.unicode.org/Public/9.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
    /// http://www.unicode.org/Public/10.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {
            GenerateBenchmarkCode();
            Generate(UnicodeVersion.V9);
            Generate(UnicodeVersion.V10);
        }

        const string @namespace = "GraphemeSplitter";

        static void Generate(UnicodeVersion version)
        {
            var items = Loader.LoadProperties(version);

            const string pathFormat = "../GraphemeSplitter/Character.{0}.cs";

            using (var w = new StreamWriter(string.Format(pathFormat, "GetGraphemeBreakProperty" + version)))
            {
                w.WriteLine("#if UnicodeVersion" + version);
                GenerateBinaryIfCode(items, "Character", "GetGraphemeBreakProperty", w);
                w.WriteLine("#endif");
            }
        }

        private static void GenerateBenchmarkCode()
        {
            var v10Items = Loader.LoadProperties(UnicodeVersion.V10)
            //.Take(1000).ToArray()
            //.Take(500).ToArray()
            //.Take(200).ToArray()
            //.Take(100).ToArray()
            //.Take(50).ToArray()
            //.Take(20).ToArray()
            ;

            const string benchmarkPathFormat = "../GraphemeBreakPropertyCodeGeneratorTest/Benchmark.{0}.cs";
            const string benchmarkTypeName = "Benchmark";

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "switch")))
                GenerateSwitchCode(v10Items, benchmarkTypeName, "GetBySwitch", w);

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "switchwhen")))
                GenerateSwitchWhenCode(v10Items, benchmarkTypeName, "GetBySwitchWhen", w);

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "binif")))
                GenerateBinaryIfCode(v10Items, benchmarkTypeName, "GetByBinaryIf", w);

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "if")))
                GenerateLinearIfCode(v10Items, benchmarkTypeName, "GetByIf", w);

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "items")))
                GenerateItemsCode(v10Items, benchmarkTypeName, w);
        }

        static void GenerateHeader(string typeName, string methodName, StreamWriter w)
        {
            w.WriteLine($@"//generated by GraphemeBreakPropertyCodeGenerator

using static {@namespace}.GraphemeBreakProperty;

namespace {@namespace}
{{
    partial class {typeName}
    {{");

            if (methodName != null)
                w.WriteLine($@"        public static GraphemeBreakProperty {methodName}(uint codePoint)
        {{");
        }

        static void GenerateSwitchCode(PropertyItem[] items, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(typeName, methodName, w);

            w.WriteLine(@"            switch (codePoint)
            {");

            var groups = items.GroupBy(x => x.Property);

            foreach (var g in groups)
            {
                foreach (var item in g)
                {
                    for (int i = item.Min; i <= item.Max; i++)
                    {
                        w.WriteLine($"                case {i}:");
                    }
                }
                w.WriteLine($"                    return {g.Key};");
            }

            w.WriteLine(@"                default: return Other;
            }
        }
    }
}");
        }

        static void GenerateSwitchWhenCode(PropertyItem[] items, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(typeName, methodName, w);

            w.WriteLine(@"            switch (codePoint)
            {");

            var groups = items.GroupBy(x => x.Property);

            int i = 0;
            foreach (var g in groups)
            {
                foreach (var item in g)
                {
                    if (item.Min == item.Max)
                    {
                        w.WriteLine($"                case {item.Min}:");
                    }
                    else
                    {
                        w.WriteLine($"                case uint i{i} when {item.Min} <= i{i} && i{i} <= {item.Max}:");
                        ++i;
                    }
                }
                w.WriteLine($"                    return {g.Key};");
            }

            w.WriteLine(@"                default: return Other;
            }
        }
    }
}");
        }

        static void GenerateBinaryIfCode(PropertyItem[] items, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(typeName, methodName, w);

            var sorted = items.OrderBy(x => x.Min).ToArray();

            void f(int lower, int upper, int nest)
            {
                var ws = new string(' ', nest * 4);

                if (lower == upper)
                {
                    var r = sorted[lower];
                    w.WriteLine($"{ws}if ({r.Min} <= codePoint && codePoint <= {r.Max}) return {r.Property};");
                    w.WriteLine($"{ws}else return Other;");
                }
                else if (lower + 1 == upper)
                {
                    var r = sorted[lower];
                    w.WriteLine($"{ws}if ({r.Min} <= codePoint && codePoint <= {r.Max}) return {r.Property};");
                    r = sorted[upper];
                    w.WriteLine($"{ws}else if ({r.Min} <= codePoint && codePoint <= {r.Max}) return {r.Property};");
                    w.WriteLine($"{ws}else return Other;");
                }
                else
                {
                    var middle = lower + (upper - lower) / 2;
                    var r = sorted[middle];

                    w.WriteLine($"{ws}if (codePoint < {r.Min})");
                    f(lower, middle - 1, nest + 1);
                    w.WriteLine($"{ws}else if ({r.Max} < codePoint)");
                    f(middle + 1, upper, nest + 1);
                    w.WriteLine($"{ws}else return {r.Property};");
                }
            }

            f(0, sorted.Length - 1, 3);

            w.WriteLine(@"        }
    }
}");
        }

        static void GenerateLinearIfCode(PropertyItem[] items, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(typeName, methodName, w);

            foreach (var item in items)
            {
                if (item.Min == item.Max)
                    w.WriteLine($"            if (codePoint == {item.Max}) return {item.Property};");
                else
                    w.WriteLine($"            if ({item.Min} <= codePoint && codePoint <= {item.Max}) return {item.Property};");
            }

            w.WriteLine(@"            return Other;
        }
    }
}");
        }

        static void GenerateItemsCode(PropertyItem[] items, string typeName, StreamWriter w)
        {
            GenerateHeader(typeName, null, w);

            w.WriteLine(@"        static readonly PropertyItem[] Items = new[]
        {
");

            foreach (var item in items.OrderBy(x => x.Min))
            {
                w.WriteLine($"            new PropertyItem({item.Min}, {item.Max}, {item.Property}),");
            }

            w.WriteLine(@"        };
    }
}");
        }
    }
}
