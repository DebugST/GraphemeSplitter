using GraphemeSplitter;
using System;
using System.IO;
using System.Linq;

namespace GraphemeBreakPropertyCodeGenerator
{
    /// <summary>
    /// generates `switch` codes from GraphemeBreakProperty definition in unicode.org
    ///
    /// http://www.unicode.org/Public/9.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
    /// http://www.unicode.org/Public/10.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {
            GenerateBenchmarkCode();
            Generate(UnicodeVersion.V9);
            Generate(UnicodeVersion.V10);
        }

        const string @namespace = "GraphemeSplitter";

        static void Generate(UnicodeVersion version)
        {
            var items = Loader.LoadProperties(version);

            const string pathFormat = "../GraphemeSplitter/Character.{0}.cs";

            using (var w = new StreamWriter(string.Format(pathFormat, "GetGraphemeBreakProperty" + version)))
            {
                w.WriteLine("#if UnicodeVersion" + version);
                GenerateSwitchCode(items, "Character", "GetGraphemeBreakProperty", w);
                w.WriteLine("#endif");
            }
        }

        private static void GenerateBenchmarkCode()
        {
            var v10Items = Loader.LoadProperties(UnicodeVersion.V10);

            const string benchmarkPathFormat = "../GraphemeBreakPropertyCodeGeneratorTest/Benchmark.{0}.cs";
            const string benchmarkTypeName = "Benchmark";

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "switch")))
                GenerateSwitchCode(v10Items, benchmarkTypeName, "GetBySwitch", w);

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "if")))
                GenerateIfCode(v10Items, benchmarkTypeName, "GetByIf", w);

            using (var w = new StreamWriter(string.Format(benchmarkPathFormat, "items")))
                GenerateItemsCode(v10Items, benchmarkTypeName, w);
        }

        static void GenerateHeader(string typeName, string methodName, StreamWriter w)
        {
            w.WriteLine($@"//generated by GraphemeBreakPropertyCodeGenerator

using static {@namespace}.GraphemeBreakProperty;

namespace {@namespace}
{{
    partial class {typeName}
    {{");

            if (methodName != null)
                w.WriteLine($@"        public static GraphemeBreakProperty {methodName}(uint codePoint)
        {{");
        }

        static void GenerateSwitchCode(PropertyItem[] items, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(typeName, methodName, w);

            w.WriteLine(@"            switch (codePoint)
            {");

            var groups = items.GroupBy(x => x.Property);

            foreach (var g in groups)
            {
                foreach (var item in g)
                {
                    for (int i = item.Min; i <= item.Max; i++)
                    {
                        w.WriteLine($"                case {i}:");
                    }
                }
                w.WriteLine($"                    return {g.Key};");
            }

            w.WriteLine(@"                default: return Other;
            }
        }
    }
}");
        }


        static void GenerateIfCode(PropertyItem[] items, string typeName, string methodName, StreamWriter w)
        {
            GenerateHeader(typeName, methodName, w);

            foreach (var item in items)
            {
                if (item.Min == item.Max)
                    w.WriteLine($"            if (codePoint == {item.Max}) return {item.Property};");
                else
                    w.WriteLine($"            if ({item.Min} <= codePoint && codePoint <= {item.Max}) return {item.Property};");
            }

            w.WriteLine(@"            return Other;
        }
    }
}");
        }

        static void GenerateItemsCode(PropertyItem[] items, string typeName, StreamWriter w)
        {
            GenerateHeader(typeName, null, w);

            w.WriteLine(@"        static readonly PropertyItem[] Items = new[]
        {
");

            foreach (var item in items.OrderBy(x => x.Min))
            {
                w.WriteLine($"            new PropertyItem({item.Min}, {item.Max}, {item.Property}),");
            }

            w.WriteLine(@"        };
    }
}");
        }
    }
}
